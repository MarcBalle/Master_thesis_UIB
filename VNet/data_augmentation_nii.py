# -*- coding: utf-8 -*-
"""data_augmentation_nii.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wAz96cbvO1-4rI-GqLR5MKEbZwCzNND1
"""

import numpy as np
import nibabel as nib
from scipy.ndimage import interpolation
from scipy.ndimage import zoom
from numpy.random import random
from itertools import cycle
import keras
import os
import time


class Transform3D(object):
    def __init__(self, rotation_range, shift_range, shear_range, zoom_range, flip, seed):
        np.random.seed(seed)

        self.rotation_angle = rotation_range * (random() - 0.5)

        self.x_shift = shift_range * (random() - 0.5)  # 0.1 * 128 * [-1,+1]
        self.y_shift = shift_range * (random() - 0.5)  # 0.1 * 128 * [-1,+1]
        self.z_shift = shift_range * (random() - 0.5)  # 0.1 * 128 * [-1,+1]

        self.shear_matrix = np.array([[1, shear_range * (random() - 0.5), shear_range * (random() - 0.5)],
                                      [shear_range * (random() - 0.5), 1, shear_range * (random() - 0.5)],
                                      [shear_range * (random() - 0.5), shear_range * (random() - 0.5), 1]])

        self.zoom_factors = np.diag([zoom_range * (random() - 0.5) for _ in range(3)])
        self.zoom_matrix = np.eye(3) - self.zoom_factors

        self.flip = flip
        self.flip_axis = []
        if self.flip:
            self.flip_axis = [x for x in range(3) if random() > 0.5]

    def __repr__(self):
        return ("rotation_angle: {rotation_angle:.2f}, ".format(rotation_angle=self.rotation_angle) +
                "xyz-shifts: ({x_shift:.2f},{y_shift:.2f},{z_shift:.2f})\n".format(x_shift=self.x_shift,
                                                                                   y_shift=self.y_shift,
                                                                                   z_shift=self.z_shift) +
                "shear_matrix: {shear_matrix}\n".format(shear_matrix=np.round(self.shear_matrix, 2).tolist()) +
                "zoom_factors: {zoom_factors}, ".format(zoom_factors=np.round(self.zoom_factors, 2).tolist()) +
                "flip_axis: {flip_axis}".format(flip_axis=self.flip_axis))

    def get_tag(self):
        r_tag = 'r{:.1f}'.format(self.rotation_angle)
        xyz_tag = 'xyz{:.0f},{:.0f},{:.0f}'.format(*np.array([self.x_shift, self.y_shift, self.z_shift]) * 100)
        f_tag = 'f{:s}'.format(str(self.flip_axis).replace('[', '').replace(']', '').replace(', ', ''))
        sz_tag = ['{:.0f}'.format(x) for x in 100 * self.shear_matrix.dot(self.zoom_matrix).flatten()]
        sz_tag = 'sz' + ','.join(sz_tag)
        tag = '_'.join((r_tag, xyz_tag, f_tag, sz_tag))
        return tag


def fit_image_to_shape(arr, dst_shape=np.array([128, 128, 128]), order=0):
    return zoom(arr, np.divide(dst_shape, arr.shape), order=order)


def transform_3d_array(arr, transform):
    """
    Return random (based on seed) transformation of 3D-array.
    Applies: rotation, shift, shear, zoom, and flip.
    Disclaimer: Tested only on 128x128x128 images.
    """

    # assert arr.shape == (128, 128, 128) # assume 128
    c_in = 0.5 * np.array(arr.shape)
    c_out = 0.5 * np.array(arr.shape)

    # Rotate: only using the z-axis (x,y-plane)
    rotated = interpolation.rotate(arr, transform.rotation_angle, axes=(0, 1), order=0, reshape=False)

    # Shift
    x_L, y_L, z_L = rotated.shape  # pixel lengths
    x_shift = x_L * transform.x_shift
    y_shift = y_L * transform.y_shift
    z_shift = z_L * transform.z_shift
    shift_offset = np.array([x_shift, y_shift, z_shift])

    # Shear
    shear_offset = c_in - c_out.dot(transform.shear_matrix)

    # Zoom
    zoom_offset = np.diag(np.array(arr.shape) / 2 * transform.zoom_factors)

    # Shift + Shear + Zoom applied
    matrix = transform.zoom_matrix.dot(transform.shear_matrix)
    offset = shift_offset + shear_offset + zoom_offset
    transformed = interpolation.affine_transform(rotated, matrix, offset=offset, order=0)

    # Flip added
    if transform.flip:
        transformed = np.flip(transformed, axis=transform.flip_axis)

    return transformed


class DataGenerator(keras.utils.Sequence):
    def __init__(self, ids, path, n_samples, batch_size=4, image_shape=(40, 40, 40),
                 augmentation=True, rotation_range=0.2, shift_range=0.2, shear_range=0.2, zoom_range=0.2, flip=True):
        self.ids = ids
        self.path = path
        self.n_samples = n_samples  # samples to create
        self.batch_size = batch_size
        # self.image_size = image_size
        # self.image_shape = (self.image_size,)*3
        self.image_shape = image_shape
        if augmentation:
            self.tids = [(name, True) for name in self.ids]  # augment orig input as well
        else:
            self.tids = [(name, False) for name in self.ids]

        self.rotation_range = rotation_range
        self.shift_range = shift_range
        self.shear_range = shear_range
        self.zoom_range = zoom_range
        self.flip = flip
        # Revisar si es necesario esta parte
        if self.n_samples > len(self.ids):  # if there's something to transform
            n_to_transform = self.n_samples - len(self.ids)
            for ix, name in enumerate(cycle(self.ids)):
                if ix < n_to_transform:
                    self.tids.append((name, True))
                else:
                    break

        self.on_epoch_end()

    def __load__(self, id_name, flag_transform):  # load single image and label
        # Path
        t2_path = os.path.join(self.path, f't2/{id_name}')  # id_name = '003_rh.nii.gz'
        seg_path = os.path.join(self.path, f'seg/{id_name}')
        # t2_path = os.path.join(self.path, id_name + '_t2.nii.gz')
        # t1ce_path = os.path.join(self.path, id_name + '_t1ce.nii.gz')
        # flair_path = os.path.join(self.path, id_name + '_flair.nii.gz')
        # seg_path = os.path.join(self.path, id_name + '_seg.nii.gz')
        assert os.path.exists(t2_path), "ERROR: {} does not exist".format(t2_path)
        assert os.path.exists(seg_path), "ERROR: {} does not exist".format(seg_path)
        # assert os.path.exists(t2_path), "ERROR: {} does not exist".format(t2_path)
        # assert os.path.exists(t1ce_path), "ERROR: {} does not exist".format(t1ce_path)
        # assert os.path.exists(flair_path), "ERROR: {} does not exist".format(flair_path)
        # assert os.path.exists(seg_path), "ERROR: {} does not exist".format(seg_path)

        # Read and concatenate normalized images
        # t1 = fit_image_to_shape(nibabel.load(t1_path).get_data(), dst_shape=self.image_shape) / 255.
        # t2 = fit_image_to_shape(nibabel.load(t2_path).get_data(), dst_shape=self.image_shape) / 255.
        # t1ce = fit_image_to_shape(nibabel.load(t1ce_path).get_data(), dst_shape=self.image_shape) / 255.
        # flair = fit_image_to_shape(nibabel.load(flair_path).get_data(), dst_shape=self.image_shape) / 255.
        # image = np.array([t1, t2, t1ce, flair]).transpose(1,2,3,0) # channels_last
        # image = np.array([flair, t1ce])#t1, t1ce, t2]) # channels_first
        # image = np.array([flair, t1, t1ce, t2])#t1, t1ce, t2]) # channels_first # Fix #6
        image = nib.load(t2_path).get_fdata()
        seg = nib.load(seg_path).get_fdata()

        # Transform if flag on
        if flag_transform:
            seed = np.random.randint(time.time() // 1000)  # set same seed for the tags of the same sample
            transform = Transform3D(self.rotation_range, self.shift_range,
                                    self.shear_range, self.zoom_range, self.flip, seed)
            image_trans = transform_3d_array(image, transform)
            #             print(transform.get_tag(), id_name) ##@##
            # for ix, arr in enumerate(image):
            #    image[ix] = transform_3d_array(arr, transform)
            # seg = fit_image_to_shape(nibabel.load(seg_path).get_data(), dst_shape=self.image_shape)
            seg_trans = transform_3d_array(seg, transform)
            return image_trans, seg_trans
        else:
            return image, seg
        # Read and concatenate labels
        # seg1 = (seg == 1) # tumor core
        # seg2 = (seg == 2) # edema
        # seg4 = (seg == 4) # enhancing
        # label = np.array([seg1, seg2, seg4]).transpose(1,2,3,0) # channels_last
        # label = np.array([seg1, seg2, seg4]) # channels_first

    def __getitem__(self, ix):  # load batch: batch_size*image, batch_size*label
        # Resize batch_size if overflown
        if (ix + 1) * self.batch_size > len(self.tids):  # when len(ids) % batch_size > 0
            self.batch_size = len(self.tids) - ix * self.batch_size

        files_batch = self.tids[ix * self.batch_size:
                                (ix + 1) * self.batch_size]
        #         print("files_batch:", files_batch) ##@##
        images, labels = [], []
        for id_name, flag_transform in files_batch:
            # load img, label corresponding to the ID
            _image, _label = self.__load__(id_name, flag_transform)
            images.append(_image)
            labels.append(_label)
        images = np.array(images)
        labels = np.array(labels)

        return images.reshape(images.shape + (1,)), labels.reshape(labels.shape + (1,))  # adding n_channels last

    def on_epoch_end(self):
        pass

    def __len__(self):
        return int(np.ceil(len(self.tids) / float(self.batch_size)))  # porque no np.floor?


"""#### Prueba sin la clase DataGenerator"""

# filenames = ['003_rh.nii.gz', '004_rh.nii.gz', '006_rh.nii.gz', '012_rh.nii.gz',
#              '013_rh.nii.gz', '014_rh.nii.gz', '015_rh.nii.gz']
#
# for file in filenames:
#   img_path = f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{file}_rh.nii.gz'
#   seg_path = f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{file}_rh.nii.gz'
#   img = nib.load(img_path)
#   seg = nib.load(seg_path)
#   img_data = img.get_fdata()
#   seg_data = seg.get_fdata()
#   img_hdr = img.header
#   seg_hdr = seg.header
#   # Transform image
#   transform = Transform3D(rotation_range=0.2, shift_range=0.2, shear_range=0.2, zoom_range=0.2, flip=True, seed = 42)
#   transformed_img = transform_3d_array(img_data, transform)
#   transformed_seg = transform_3d_array(seg_data, transform)
#   # Save images
#   img_trans = nib.Nifti1Image(transformed_img, img.affine, img_hdr)
#   seg_trans = nib.Nifti1Image(transformed_seg, seg.affine, seg_hdr)
#   nib.save(img_trans, f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{file}_aug.nii.gz')
#   nib.save(seg_trans, f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{file}_aug.nii.gz')
#
# """#### Prueba con la clase DataGenerator"""
#
# src_dir = './drive/MyDrive/DP_Vision/input_data_augmentation/'
#
# data_gen = DataGenerator(filenames, src_dir, n_samples = len(filenames),
#                          batch_size=1)
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[0]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[0]}')
# image003, seg003 = data_gen.__getitem__(ix = 0)
# img_trans = nib.Nifti1Image(image003[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg003[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/003_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/003_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[1]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[1]}')
# image004, seg004 = data_gen.__getitem__(ix = 1)
# img_trans = nib.Nifti1Image(image004[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg004[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/004_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/004_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[2]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[2]}')
# image006, seg006 = data_gen.__getitem__(ix = 2)
# img_trans = nib.Nifti1Image(image006[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg006[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/006_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/006_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[3]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[3]}')
# image012, seg012 = data_gen.__getitem__(ix = 3)
# img_trans = nib.Nifti1Image(image012[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg012[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/012_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/012_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[4]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[4]}')
# image013, seg013 = data_gen.__getitem__(ix = 4)
# img_trans = nib.Nifti1Image(image013[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg013[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/013_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/013_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[5]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[5]}')
# image014, seg014 = data_gen.__getitem__(ix = 5)
# img_trans = nib.Nifti1Image(image014[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg014[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/014_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/014_augData.nii.gz')
#
# img = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/t2/{filenames[6]}')
# seg = nib.load(f'./drive/MyDrive/DP_Vision/input_data_augmentation/seg/{filenames[6]}')
# image015, seg015 = data_gen.__getitem__(ix = 6)
# img_trans = nib.Nifti1Image(image015[0], img.affine, img.header)
# seg_trans = nib.Nifti1Image(seg015[0], seg.affine, seg.header)
# nib.save(img_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/t2/015_augData.nii.gz')
# nib.save(seg_trans, './drive/MyDrive/DP_Vision/input_data_augmentation/seg/015_augData.nii.gz')
